# Тестовое приложение для DIS Group

---

## Описание технологий

Мною было разработано REST Full приложение на реактивном стеке Spring, который я для этого изучил в процессе разработки.

### Технологии:

- Spring Reactive Web (WebFlux)
- Spring Boot
- Java 11
- PostgreSQL
- MupStruct
- Docker, Docker-compose

---

## Запуск

### Запуск из IDEA

Для запуска необходимо развернуть базу данных (файл dev_env.yaml) после чего
запустить SpringBoot приложение. Возможно понадобится выполнить

```shell
mvn clean install   
```

для того, чтобы MapStruct создал коверторы.

### Запуск контейнерной версии

Для такого типа запуска необходимо выполнить

```shell
docker-compose up
```

в корневой дериктории проекта.

---

## Использование

### Коллекция запросов

Для удобства обращения к эндпоинтам можно воспользоваться Postman.
Ссылка на коллекцию запросов:

[![Run in Postman](https://run.pstmn.io/button.svg)](https://app.getpostman.com/run-collection/18008912-af0f59f0-cdb6-41f5-8ee1-dd65c30400ce?action=collection%2Ffork&collection-url=entityId%3D18008912-af0f59f0-cdb6-41f5-8ee1-dd65c30400ce%26entityType%3Dcollection%26workspaceId%3D84764ea3-9a70-4402-a714-ce555857c892)

Все запросы происходят на базовый URL:

```
localhost:8080/api/v1
```

### Возможности реализации

Для каждой сущности реализованы следующие запросы:

- Создание сущности (POST method)
- Обновление всех полей сущности (PUT method)
- Обновление выбранных полей сущности (PATCH method)
- Удаление всех сущностей (DELETE method без параметров)
- Удаление сущности по id (DELETE method с параметром)
- Получение сущности по id (GET method с параметром)
- Получение всех сущностей с возможностью многоуровневой сортировки и фильтрации по нескольким полям (GET method без
  параметров)

Для статей так же доступен метод удаления всех статей с определенным продуктом (DELETE method на адрес: *
*article/product/{product_id}**)

### Структура сущностей

Для создания статьи используется **CArticleEntityDTO.java**

Для удаления/обновления/патча статьи используется **ArticleEntityDTO.java**

Для чтения статьи используется **ArticleDTO.java**

---
Для создания продукта используется **CProductEntityDTO.java**

Для удаления/обновления/патча продукта используется **ProductEntityDTO.java**

Для чтения продукта используется **ProductDTO.java**

---

Сущности базы данных представлены **ArticleEntity.java**, **ProductEntity.java**

--- 

Скрипт создания БД представлен в **db.sql**

Все поля сущностей выставлены в NOT NULL, есть внешний ключ для продукта и имена продуктов и статей заявлены как UNIQUE.

### Подробнее про запросы

#### Общая информация

Для всех запросов предусмотрена обработка исключений связанных с некорректностью введенных данных или же нарушения
ограничений, таких как добавление статьи к несуществующему продукту, уникальность имен, удаление продукта у которого
есть
статьи и т.п. Такие ошибки возвращают 409 или 400 код.

#### Специфичная для разных типов операций

Для запросов PUTCH реализовано обновление только тех полей, которые были в запросе. Для корректного запроса необходим
id.

---
Для запросов UPDATE реализовано обновление всех полей сущности. При попытке задать уже существующее имя или задать
значение NULL
полям будут выданы соответствующие ошибки.

---

Для запросов GET (**getAllArticles, getAllProducts**) доступна многоуровневая сортировка результата.
Также доступны многоуровневые фильтры с поддержкой широкого набора операций, зависящих от типа поля. Оба механизма
пришлось писать самому.

Для сортировки необходим Query param **sorted_by** формата:

```
asc/desc(name1),asc/desc(name2),...
```

В контроллерах можно изменять набор допустимых полей для сортировки путем изменения переменной **allowedNamesForSort**

Для фильтрации необходим Query param **filtered_by** формата LHS:

```
field1[operation1]=value1,field2[operation2]=value2...
```

Поддерживаются следующие операции для типов данных:

```
for String:
    `cont` -> `contains`, `eq` -> `=`, `neq` -> `!=`
for Long, Float:
    `eq` -> `=`, `neq` -> `!=`, `gr` -> `>`, `egr -> `>=`, `le` -> `<`, `ele` -> `<=`
for Date:
    `eq` -> `=`, `neq` -> `!=`, `gr` -> `>`, `le` -> `<`
```

В контроллерах можно изменять набор допустимых полей для сортировки путем изменения переменной **allowedNamesForFilter**
> Note: Фильтрация к сожалению происходит в оперативной памяти, а не на уровне DB, так как WebFlux не поддерживает
> стандартные
> реализации JPA, а в R2DBC еще нет Criteria API. 

